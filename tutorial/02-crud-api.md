# 02 - A basic CRUD API with TDD

Code for this chapter available [here](/src/02-crud-api/).

With our fresh environment we will start to get hands on with API Star. In this section we will construct a simple CRUD (*Create, Read, Update and Delete*) api **to manage a TODO list**.

We will put special enfasis on testing, using `py.test` testing framework, which is included in API Star. We will follow some principles of TDD (*Test Driven Development*).

## Just another TODO list API

The TODO List is the 'hello world' of the XXI century. In this basic example, a user must be able to create or delete a **Task**, as well as mark it as completed. It should also list every **Task**, and maybe allow to filter by a completed query string param.

The endpoints of our API that will be developed in this chapter are:

 * `GET /task/`: Retrieve a list of tasks.
 * `POST /task/`: Create a new task.
 * `PUT /task/{id}/`: Update some field of an specific task by id (i.e. mark as completed)
 * `DELETE /task/{id}/`: Delete a task by id. 

## Testing a dumb view

We will start using the code structure generated in Chapter 1, adding the `GET` and `POST` verbs over the /task/ endpoint to allow to create new tasks and list them. To temporarily persist our list of tasks, we will use an in memory global variable. In next chapters we will substitute this using SQLAlchemy as database backend.

Furthermore we will create a Task schema. API Star provides a typing system to define your API interface. `Schemas` are defined as specification of input/output data contracts for your views, validating your input and serializing your output (as libraries such as [marshmallow](https://marshmallow.readthedocs.io/en/latest/) do).

Let's start adding some dumb views in our `project/views.py` file:

```python
    def list_tasks():
        return {}

    def create_task():
        return {}
```

And add their routes in `routes.py` taking advantatge of `Include` to isolate the task related routes:

```python
    [...]
    from project.views import list_tasks, create_task

    task_routes = [
        Route('/', 'GET', list_tasks),
        Route('/', 'POST', create_task),
    ]

    routes = [
        Route('/', 'GET', welcome),
        Include('/task', task_routes),
        Include('/docs', docs_routes),
        Include('/static', static_routes)
    ]
```

Now we have just created our first dumb connected views. But wait, were is the [Red-Green-Refactor](http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)?

Some tests are generated by apistar in the example of chapter 1, so we can run them. Add this service to the `docker-compose.yml`, and we can move some of the parameters from the api service to the base:

```
version: '2'

services:
  base:
    build: .
    entrypoint: apistar
    working_dir: /app
    volumes:
      - "./api:/app"

  api:
    extends: base
    command: ["run", "--host", "0.0.0.0", "--port", "80"]
    ports:
      - "8080:80"

  test:
    extends: base
    command: ["test"]
```

And simply run the test suite with:

```sh
docker-compose run test
  ========================================================================= test session starts =========================================================================
  platform linux -- Python 3.6.1, pytest-3.1.2, py-1.4.34, pluggy-0.4.0
  rootdir: /app, inifile:
  collected 2 items

  tests/test_app.py ..

  ====================================================================== 2 passed in 0.02 seconds =======================================================================
```

### py.test

Add two simple tests at `tests/test_app.py` that call the views and assert that they return an empty dictionary.

```python
from project.views import list_tasks, add_task

def test_add_task():
    assert add_task() == {}

def test_list_tasks():
    assert list_tasks() == {}
```

Run again the tests and.. nice! We are green! Let's start implementing the views. List tasks initially should return an empty list.

```python
# test_app.py
def test_list_tasks():
    assert list_tasks() == []

# views.py
tasks = []

def list_tasks():
    """ Return a list of tasks """
    return tasks
```
> Note: I will present both the test and the modified view, the idea is to drive our development thinking about the expected behaviour writting the test before the code.

#### TestClient

API Star also provides a test client wrapping `requests` to test your app. We have tested the views directly, but we could also add a few http tests using this client:

```python
from apistar.test import TestClient

client = TestClient()

def test_http_list_tasks():
    response = client.get('/tasks/')
    assert response.status_code == 200
    assert response.json() == []

def test_http_add_task():
    response = client.post('/tasks/')
    assert response.status_code == 200
    assert response.json() == {}
```

## Schemas

To define the interface of this views we create an schema of our **Task** object, and a simple **TaskDefinition** constraining the max length of the string on input.

```python
# schemas.py
from apistar import schema

class TaskDefinition(schema.String):
    max_length = 128

class Task(schema.Object):
    properties = {
        'definition': TaskDefinition,
        'completed': schema.Boolean(default=False),
    }
```

This schemas allow us to validate the input of the create task, and serialize the output of the both views. API Star allows us to annotate the route handlers with the expected input and output, it's like magic :-)

```python
# views.py
from typing import List

from project.schemas import Task, TaskDefinition

def list_task() -> List[Task]:
    return [Task(t) for t in tasks]

def add_task(definition: TaskDefinition) -> Task:
    new_task = Task({'definition': definition})
    task.append(new_task)
    return new_task

# test_task.py
from apistar.test import TestClient

task_endpoint = '/task/'
client = TestClient()

new_task = {'definition': 'test task'}
added_task = {'definition': 'test task', 'completed': False}

def test_list_tasks():
    response = client.get(task_endpoint)
    assert response.status_code == 200
    assert response.json() == []

def test_add_task():
    response = client.post(task_endpoint, new_task)
    assert response.status_code == 200

    assert response.json() == added_task

def test_list_an_added_task():
    response = client.get(task_endpoint)
    assert response.status_code == 200
    assert response.json() == [added_task]

    test_add_task()
    response = client.get(task_endpoint)
    assert response.status_code == 200
    assert response.json() == [added_task, added_task]
```
> Note: We have extracted the tests related with the `/task/` API endpoint in `tests/test_task.py`.

Take a look to the views annotated with the Schemas previously defined. `list_task` returns a list of serialized task items, and `add_task` gets input via type annotation, with a validated definition.

Until now we have just tested the happy path, and that's just naive! But we will let that as an exercise to the reader. Fork the project and add some tests.

### Views to delete and update task

Let's add the pending functionality: mark a todo task as completed and delete a task.

Until now our schema does not include an unique `id` value for tasks, so we cannot identify a concrete task (because different tasks could have the same definition and completion state). Also the data structure that we have used to persist the tasks in memory, a list, it's not specially suited for indexing by key, deleting tasks, etc.

TODO
  - start modifying the existing code to extend schema with an id
  - consider using a closure for the autoincremental id

Next section: [03 - Database backend](03-database-backend.md#readme)

Back to the [table of contents](https://github.com/servomac/apistar-from-scratch#table-of-contents).