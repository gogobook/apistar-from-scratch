# 02 - A basic CRUD API with TDD

Code for this chapter available [here](/src/02-crud-api/).

With our fresh environment we will start to get hands on with API Star. In this section we will construct a simple CRUD (*Create, Read, Update and Delete*) api **to manage a TODO list**.

We will put special enfasis on testing, using `py.test` testing framework, which is included in API Star. We will follow some principles of TDD (*Test Driven Development*).

## A TODO List

The TODO List is the 'hello world' of the XXI century. In this basic example, a user could create or delete a **Task**, as well as mark it as completed. It should also list every **Task**, and maybe allow to filter by a completed query string param.

The endpoints of our API will be:

 * `GET /task/`: Retrieve a list of tasks.
 * `POST /task/`: Create a new task.
 * `GET /task/{id}/`: Retrieve an specific task by id.
 * `PUT /task/{id}/`: Update some field of an specific task (i.e. mark as completed)
 * `DELETE /task/{id}/`: Delete a task by id. 

## Testing a dumb view

We will start using the code structure generated in Chapter 1, adding the `GET` and `POST` verbs over the /task/ endpoint to allow to create new tasks and list them. To temporarily persist our list of tasks, we will use an in memory global variable. In next chapters we will substitute this using SQLAlchemy as database backend.

Furthermore we will create a Task schema. API Star provides a typing system to define your API interface. `Schemas` are defined as specification of input/output data contracts for your views, validating your input and serializing your output (as libraries such as [marshmallow](https://marshmallow.readthedocs.io/en/latest/) do).

Let's start adding some dumb views in our `project/views.py` file:

```python
    def list_tasks():
        return {}

    def create_task():
        return {}
```

And add their routes in `routes.py` taking advantatge of `Include` to isolate the task related routes:

```python
    [...]
    from project.views import list_tasks, create_task

    task_routes = [
        Route('/', 'GET', list_tasks),
        Route('/', 'POST', create_task),
    ]

    routes = [
        Route('/', 'GET', welcome),
        Include('/task', task_routes),
        Include('/docs', docs_routes),
        Include('/static', static_routes)
    ]
```

Now we have just created our first dumb connected views. But wait, were is the [Red-Green-Refactor](http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)?

Some tests are generated by apistar in the example of chapter 1, so we can run them. Add this service to the `docker-compose.yml`, and we can move some of the parameters from the api service to the base:

```
version: '2'

services:
  base:
    build: .
    entrypoint: apistar
    working_dir: /app
    volumes:
      - "./api:/app"

  api:
    extends: base
    command: ["run", "--host", "0.0.0.0", "--port", "80"]
    ports:
      - "8080:80"

  test:
    extends: base
    command: ["test"]
```

And simply run the test suite with:

```sh
docker-compose run test
  ========================================================================= test session starts =========================================================================
  platform linux -- Python 3.6.1, pytest-3.1.2, py-1.4.34, pluggy-0.4.0
  rootdir: /app, inifile:
  collected 2 items

  tests/test_app.py ..

  ====================================================================== 2 passed in 0.02 seconds =======================================================================
```

### py.test

In `tests/test_app.yml`, add two simple tests that call the views and assert that they return an empty dictionary.

```python
from project.views import list_tasks, add_task

def test_add_task():
    assert add_task() == {}

def test_list_tasks():
    assert list_tasks() == {}
```

Run again the tests and.. nice! We are green! Let's start implementing the views. List tasks initially should return an empty list.

```python
# test_app.py
def test_list_tasks():
    assert list_tasks() == []

# views.py
tasks = []

def list_tasks():
    """ Return a list of tasks """
    return tasks
```
> Note: I will present both the test and the modified view, the idea is to drive our development thinking about the expected behaviour writting the test before the code.

#### TestClient

TODO explain

## Schemas

To define the interface of this views we create an schema of our **Task** object, and a simple **TaskDefinition** constraining the max length of the string on input.

```python
# schemas.py
from apistar import schema

class TaskDefinition(schema.String):
    max_length = 128

class Task(schema.Object):
    properties = {
        'definition': TaskDefinition,
        'completed': schema.Boolean(default=False),
    }
```

This schemas allow us to validate the input of the create task, and serialize the output of the both views. API Star allows us to annotate the route handlers with the expected input and output, it's like magic :-)

```python
# views.py
from typing import List

from project.schemas import Task, TaskDefinition

def list_task() -> List[Task]:
    return [Task(t) for t in tasks]

def add_task(definition: TaskDefinition) -> Task:
    new_task = Task({'definition': definition})
    task.append(new_task)
    return new_task

# test_task.py
from apistar.test import TestClient

task_endpoint = '/task/'
client = TestClient()

def test_list_tasks():
    response = client.get(task_endpoint)
    assert response.status_code == 200
    assert response.json() == []

def test_add_task():
    new_task = {'definition': 'test task'}

    response = client.post(task_endpoint, new_task)
    assert response.status_code == 200

    result = new_task
    result['completed'] = False
    assert response.json() == result

```
> Note: We have extracted the tests related with the `/task/` API endpoint in `tests/test_task.py`.
